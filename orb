#!/bin/bash
_orb_dir=$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )
_scripts=( git utils text ) # otherwise defaults to orb
_core_dependencies=(
	core/helpers/bootstrap.sh
	core/helpers/help.sh
	core/helpers/arguments.sh
	scripts/text/core.sh
	scripts/utils/core.sh
)

_core_globals=(
	core/globals/orb.sh
	core/globals/caller.sh
	core/globals/script.sh
)

for _file in "${_core_dependencies[@]}"; do
	source "$_orb_dir/$_file"
done; unset _file


function orb() {
	# Overriding nested orb calls with internal function to access caller info in utils
	# Run nested calls in subshell to prevent changing parent environment
	(
		# Set globals
		for _file in "${_core_globals[@]}"; do
			source "$_orb_dir/$_file"
		done; unset _file

		# Source script wrapper
		if [[ -f "$_script_dir/_${_script_name}.sh" ]]; then
			source "$_script_dir/_${_script_name}.sh"
		fi

		# _echoerr 'after wrapper?'

		_collect_script_files
		# _echoerr 'after collection?'

		# If file has public function, source and call it
		for _file in ${_script_files[@]}; do
			if _has_public_function "$_function_name" "$_file"; then
				source "$_file"
				break
			fi
		done; unset _file


		# _echoerr "sourced $_function_name"

		_handle_function_is_missing_or_help

		# Parse function args
		if $_direct_call; then
			( $_function_name "$@" )
			exit $?
		elif [[ $1 == "help" ]]; then
			_print_function_help
			exit 0
		else
			_parse_args "$@"
		fi

		# IM GONNA check if extention declares function exists in subhells and return good
		# before actually sourcing the file here. That should solve this shit
		# _enforce_orb_prefix # effectively enforcing orb prefix

		# Call function in another subshell to prevent meddeling with orb internals
		( $_function_name "${_args_nrs[@]}" "${_args_wildcard[@]}" )
	)
}

orb "$@"
